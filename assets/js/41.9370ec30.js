(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{410:function(e,t,a){"use strict";a.r(t);var s=a(19),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"路由切换同一组件不更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由切换同一组件不更新"}},[e._v("#")]),e._v(" 路由切换同一组件不更新")]),e._v(" "),a("p",[e._v("在使用 Vue 组件时，在项目中遇到同一组件不同路由切换，或者统一组件同一路由不同参数地址切换时，组件的生命周期钩子不会重新触发。")]),e._v(" "),a("p",[e._v("如一个 User 组件，其路由配置如下：")]),e._v(" "),a("div",{staticClass:"language-vue line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[e._v("{ path: '/user/:id', component: User }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("当我们从 "),a("code",[e._v("/user/1")]),e._v(" 切换至 "),a("code",[e._v("/user/2")]),e._v(" 的时候，由于 vue-router 内部会识别这两个路由使用的是同一个组件从而进行复用，不会重新创建组件，从而导致生命周期钩子不会触发。")]),e._v(" "),a("p",[e._v("一个相同组件销毁再重新创建，会导致很大程度上的性能浪费，因此复用组件是正确的选择，但这同时会导致无法路由跳转的时候无法进行更新。下面总结了三种方法来解决这个问题。")]),e._v(" "),a("h2",{attrs:{id:"router-view-上绑定-key-值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#router-view-上绑定-key-值"}},[e._v("#")]),e._v(" Router-view 上绑定 key 值")]),e._v(" "),a("p",[e._v("通过在 router-view 上设置 key 值，从而通过虚拟 DOM 在渲染时通过 key 值不等来确定节点不同，导致每次切换路由的时候就会销毁之前的组件，创建一个新组件，即使是同一个组件，只要 key 值不同，就会重新创建。其示例如下：")]),e._v(" "),a("div",{staticClass:"language-vue line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[e._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("router-view")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v(":key")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("$route.fullPath"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("router-view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这种方式非常浪费性能，是最不可取的，但是简单粗暴。")]),e._v(" "),a("h2",{attrs:{id:"监听-route-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听-route-对象"}},[e._v("#")]),e._v(" 监听 $route 对象")]),e._v(" "),a("p",[e._v("通过在 watch 中监听路由对象的变化，从而进行响应的操作，如下所示：")]),e._v(" "),a("div",{staticClass:"language-vue line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[e._v("watch: {\n '$route.params.id'(to, from) {\n    console.log('route watch was called')\n  }\n},\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("这种方法可以解决上面的问题，代价是组件内部多了一个 watch，带来依赖追踪的内存消耗。一般建议只监听自己需要的字段，而不是监听整个 $route。")]),e._v(" "),a("h2",{attrs:{id:"组件内的路由导航守卫-beforerouteupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件内的路由导航守卫-beforerouteupdate"}},[e._v("#")]),e._v(" 组件内的路由导航守卫 beforeRouteUpdate")]),e._v(" "),a("p",[e._v("通过"),a("a",{attrs:{href:"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),a("OutboundLink")],1),e._v("可知，该守卫在当前路由改变，但是组件被复用的时候进行调用，虽然不会触发生命周期钩子函数，但是通过将切换路由里面的逻辑放到 beforeRouteUpdate 守卫中即可进行响应的请求和逻辑处理。")]),e._v(" "),a("p",[e._v("以上相关代码示例见下方 CodePen")]),e._v(" "),a("iframe",{staticStyle:{width:"100%"},attrs:{height:"265",scrolling:"no",title:"同一组件路由跳转生命周期不调用解决办法",src:"https://codepen.io/lullabies/embed/rNMRPvW?height=265&theme-id=dark&default-tab=html,result",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"}},[e._v("\n  See the Pen "),a("a",{attrs:{href:"https://codepen.io/lullabies/pen/rNMRPvW"}},[e._v("同一组件路由跳转生命周期不调用解决办法")]),e._v(" by ScriptLearner\n  ("),a("a",{attrs:{href:"https://codepen.io/lullabies"}},[e._v("@lullabies")]),e._v(") on "),a("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(".\n")])])}),[],!1,null,null,null);t.default=r.exports}}]);